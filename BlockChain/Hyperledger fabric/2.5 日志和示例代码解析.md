### fabric-samples

#### first-network

* `.env`：存储环境变量

* `base/`：存储 docker-compose 的公共服务

* `byfn.sh`：启动脚本

  ```shell 
  byfn.sh -m up
  byfn.sh -m down
  byfn.sh -m restart
  byfn.sh -m generate # 生成证书及创世区块
  ```

* `configtx.yaml` 及 `crypto-config.yaml`：用于生成配置文件至 `channel-artifacts` 及 `crypto-config` 目录下

* `docker-compose-xxx`：用于启动网络

* `scripts/`：存储测试脚本，如创建通道、加入通道、安装链码、实例化链码及与链码进行交互

执行

```shell 
./byfn.sh -m generate -c <通道名>
```

此命令将会做一下操作：

1. 使用 `cryptogen` 生成参与组织的 MSP 证书，`first-network` 中有两个组织。
2. 使用 `configtxgen` 生成创世区块及通道配置文件。
3. 生成两个组织的锚节点，锚节点是组织对外的节点。

查看 `crypto-config.yaml` 配置：

```yaml
OrdererOrgs:
  - Name: Orderer
    Domain: example.co
    Specs:
      - Hostname: orderer
      - Hostname: orderer2
      - Hostname: orderer3
      - Hostname: orderer4
      - Hostname: orderer5
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    EnableNodeOUs: true
    Template:
      Count: 2
      # Start: 5
      # Hostname: {{.Prefix}}{{.Index}} # default
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    EnableNodeOUs: true
    Template:
      Count: 2
    Users:
      Count: 1
```

查看生成的目录 `first-network/crypto-config`，可以看到生成了 `orderer` 和 `peer` 的配置目录：

```shell 
- ordererOrganizations/
- peerOrganizations/
```

查看 `peerOrganizations` 目录中其中一个组织的目录：

```shell 
- ca/ # 存储 CA 证书以及私钥
- msp/ # 存储管理员证书以及中间证书
- peers/ # 存储 peer 相关的证书
- tlsca
- users # 用户相关证书
```

查看生成的目录 `first-network/channel-artifacts`：

```shell 
- channel.tx # 上面创建的通道
- genesis.block # 创世区块
- Org1MSPanchors.tx # 组织的锚节点配置
- Org2MSPanchors.tx
```

查看文件 `first-network/configtx.yaml`

`Profiles` 定义了网络启动时包含了哪些组织，`Organizations` 定义了组织的详细信息 ......

启动网络：

```shell 
./byfn.sh -m up -c <通道名>
```

看见以下 log 代表网络启动完毕：

```shell 

 ____    _____      _      ____    _____ 
/ ___|  |_   _|    / \    |  _ \  |_   _|
\___ \    | |     / _ \   | |_) |   | |  
 ___) |   | |    / ___ \  |  _ <    | |  
|____/    |_|   /_/   \_\ |_| \_\   |_|  

Build your first network (BYFN) end-to-end test
```

启动完毕后，将会执行 `scripts` 目录下的脚本，包含创建通道、加入通道、更新通道锚节点等信息以及链码的安装、实例化与交互等。

以下 log 说明通道创建完成：

```shell
===================== Channel '<通道名>' created =====================
```

以下 log 说明某组织的某节点已加入通道：

```shell 
===================== peer0.org1 joined channel '<通道名>' =====================
```

以下 log 说明某组织的锚节点已更新

```shell 
===================== Anchor peers updated for org 'Org1MSP' on channel '<通道名>' =====================
```

以下 log 说明某组织的某节点已安装链码（chaincode）

```shell 
===================== Chaincode is installed on peer0.org1 =====================
```

以下 log 说明对某组织的某节点进行了查询：

```shell 
100 # 查询结果
===================== Query successful on peer0.org1 on channel '<通道名>' =====================
Sending invoke transaction on peer0.org1 peer0.org2... # 进行了交互
```

结束

```shell 

========= All GOOD, BYFN execution completed =========== 


 _____   _   _   ____   
| ____| | \ | | |  _ \  
|  _|   |  \| | | | | | 
| |___  | |\  | | |_| | 
|_____| |_| \_| |____/  
```

查看 docker 容器：

```shell 
docker ps -a
```

* `order` 节点
* `peer` 节点
* `cli` 客户端：用于远程连接对 peer 节点进行诸如链码安装、初始化等操作。

查看链码镜像：

```shell 
docker images
```

名如`dev-peer1.org2.example.com` 的镜像为链码，虽然只有一个链码，但每个 peer 节点都会生成一个链码镜像。

研究脚本

`byfn.sh` 为启动脚本，对 `scripts/` 目录中的脚本进行了调用，接下来研究一下链码相关的内容。观察 `scripts/utils.sh`。

`packageChaincode()`打包链码，核心命令：

```shell
peer lifecycle chaincode package mycc.tar.gz --path ${CC_SRC_PATH} --lang ${CC_RUNTIME_LANGUAGE} --label mycc_${VERSION} >&log.txt
```

`installChaincode()`把链码安装到区块链上，核心命令：

```shell
 peer lifecycle chaincode install mycc.tar.gz >&log.txt
```

`chaincodeInvoke()` 调用 chaincode 的 `Init()` 或 `Invoke()` 接口：

```shell
# chaincodeInvoke IS_INIT PEER ORG (PEER ORG) ...
# Accepts as many peer/org pairs as desired and requests endorsement from each
chaincodeInvoke() {
  IS_INIT=$1
  shift
  parsePeerConnectionParameters $@
  res=$?
  verifyResult $res "Invoke transaction failed on channel '$CHANNEL_NAME' due to uneven number of peer and org parameters "

  if [ "${IS_INIT}" -eq "1" ]; then
    CCARGS='{"Args":["Init","a","100","b","100"]}' # Init() 参数
    INIT_ARG="--isInit"
  else
    CCARGS='{"Args":["invoke","a","b","10"]}' # Invoke() 参数
    INIT_ARG=""
  fi

  # while 'peer chaincode' command can get the orderer endpoint from the
  # peer (if join was successful), let's supply it directly as we know
  # it using the "-o" option
  if [ -z "$CORE_PEER_TLS_ENABLED" -o "$CORE_PEER_TLS_ENABLED" = "false" ]; then
    set -x
    peer chaincode invoke -o orderer.example.com:7050 -C $CHANNEL_NAME -n mycc $PEER_CONN_PARMS ${INIT_ARG} -c ${CCARGS} >&log.txt
    res=$?
    set +x
  else
    set -x
    peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc $PEER_CONN_PARMS ${INIT_ARG} -c ${CCARGS} >&log.txt
    res=$?
    set +x
  fi
  cat log.txt
  verifyResult $res "Invoke execution on $PEERS failed "
  echo "===================== Invoke transaction successful on $PEERS on channel '$CHANNEL_NAME' ===================== "
  echo
}
```



#### test-network 

你可以运行 `test-network` 的本地节点来学习 Fabric。有经验的开发者可以用该网络来测试只能合约和应用。也就是说，这个网络仅仅是作为学习和测试的工具。我们可以以它为范本部署生产环境的区块链网络。在 v2.0 以后，`first-network` 将被 `test-network` 取代。

##### 启动 test network

进入 `test-network` 目录，查看 `./network.sh` 帮助信息

```shell
cd fabric-samples/test-network
./network.sh -h
```

```shell
Usage:
  network.sh <Mode> [Flags]
    <Mode>
      - 'up' - 启动 orderer 和 peer 节点，不创建通道（channel）
      - 'up createChannel' - bring up fabric network with one channel
      - 'createChannel' - create and join a channel after the network is created
      - 'deployCC' - deploy the fabcar chaincode on the channel
      - 'down' - clear the network with docker-compose down
      - 'restart' - restart the network

    Flags:
    -ca <use CAs> -  create Certificate Authorities to generate the crypto material
    -c <channel name> - channel name to use (defaults to "mychannel")
    -s <dbtype> - the database backend to use: goleveldb (default) or couchdb
    -r <max retry> - CLI times out after certain number of attempts (defaults to 5)
    -d <delay> - delay duration in seconds (defaults to 3)
    -l <language> - the programming language of the chaincode to deploy: go (default), javascript, or java
    -v <version>  - chaincode version. Must be a round number, 1, 2, 3, etc
    -i <imagetag> - the tag to be used to launch the network (defaults to "latest")
    -verbose - verbose mode
  network.sh -h (print this message)

 Possible Mode and flags
  network.sh up -ca -c -r -d -s -i -verbose
  network.sh up createChannel -ca -c -r -d -s -i -verbose
  network.sh createChannel -c -r -d -verbose
  network.sh deployCC -l -v -r -d -verbose

 Taking all defaults:
    network.sh up

 Examples:
  network.sh up createChannel -ca -c mychannel -s couchdb -i 2.0.0
  network.sh createChannel -c channelName
  network.sh deployCC -l javascript
```

执行

```shell 
./network.sh up
```

此命令会创建一个 Fabric 网络，网络包含两个 peer 节点，一个 排序节点（odering node），而不会创建通道（channel），log 如下：

```shell
Creating volume "net_orderer.example.com" with default driver
Creating volume "net_peer0.org1.example.com" with default driver
Creating volume "net_peer0.org2.example.com" with default driver
Creating orderer.example.com    ... done
Creating peer0.org2.example.com ... done
Creating peer0.org1.example.com ... done
CONTAINER ID        IMAGE                               COMMAND             CREATED             STATUS                  PORTS                              NAMES
8d0c74b9d6af        hyperledger/fabric-orderer:latest   "orderer"           4 seconds ago       Up Less than a second   0.0.0.0:7050->7050/tcp             orderer.example.com
ea1cf82b5b99        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up Less than a second   0.0.0.0:7051->7051/tcp             peer0.org1.example.com
cd8d9b23cb56        hyperledger/fabric-peer:latest      "peer node start"   4 seconds ago       Up 1 second             7051/tcp, 0.0.0.0:9051->9051/tcp   peer0.org2.example.com
```

##### test network 的网络组件

test network 启动以后，通过 `docker ps -a` 命令，我们可以看到三个节点容器。与 Fabric 网络交互的节点或用户必须为组织的成员，而这个组织也必须是 Fabric 网络的成员。属于 Fabric 网络的组织群体被称为联盟。test network 联盟有两个成员，Org1 与 Org2。网络同时包含一个维护网络顺序的 orderer 组织（oderer orgnization），即排序节点。

Peer 节点是 Fabric 网络的基本组件。Peer 负责存储区块链账本和在交易提交到账本前进行校验。Peer 节点运行包含业务逻辑的智能合约（smart contracts），智能合约用于管理区块链账本中存储的资产。

每个 peer 节点都必须是联盟的成员。在 test network 中，每个组织都运营属于自己的 peer 节点。如`peer0.org1.example.com` 与 `peer0.org2.example.com`。

每个 Fabric 网络都包含一个排序服务（ordering service）。Peer 节点在校验交易和添加交易记录到区块链账本中的时候不决定交易顺序或将他们添加到区块链账本中。在分布式网络中，peer 节点可能彼此远离，对交易创建的时间没有共识。因为达成共识对于 peer 节点来说是一个开销较大的过程。

排序服务允许 peer 节点专注于校验交易及将交易提交到账本。当排序节点（ordering nodes）从客户端收到背书交易（endorsed transactions），排序节点之间将会就交易顺序达成共识，并把区块添加到区块链账本中。此后，这些区块建会被分发到 peer 节点，peer 节点再将它们添加到（本地的）区块链账本中。排序节点也会操作系统通道（system channel），系统通道定义了 Fabric 网络的功能，例如区块如何创建，节点能够使用哪个版本的 Fabric，哪些组织是联盟的成员。

sample network 项目使用了单节点 Raft 排序服务（Raft ordering service），该节点由排序组织（ordering organization）操作。我们可以看到排序节点（ordering node）的容器名为 `orderer.example.com`。虽然 test network 只使用了单节点排序服务，但是在实际使用场景中，应使用多个排序节点，这些节点由一个或多个 orderer 组织运营。排序节点之间会使用 Raft 共识算法（Raft consensus algorithm）就整个网络的交易顺序达成共识。

##### 创建通道

目前我们的机器上运行了 peer 节点及 orderer 节点，因此我们可以使用脚本来为 Org1 与 Org2 之间的交易创建一个 Fabric 通道，通道（Channels）是特点网络成员之间进行交流的私有层。通道只能被邀请进入通道的组织使用，且对网络的其它成员不可见。每个通道拥有一个独立的区块链账本。受邀把节点“加入”通道的组织负责存储通道账本和校验通道的交易。

我们可以使用 `network.sh` 脚本赛 Org1 与 Org2 之间创建一个通道，并把他们的 peer 节点加入到通道中。运行一下命令可以使用默认通道名 `mychannel` 创建一个通道：

```shell
./network.sh createChannel
```

如果命令被成功执行，我们可以看到以下内容被输出到 logs 中：

```shell
========= Channel successfully joined ===========
```

我们可以指定名称创建通道，下面命令创建了名为 `channel1` 的通道：

```shell
./network.sh createChannel -c channel1
```



### 链码代码解析

查看链码代码，以 `fabric-samples/chaincode/abstore/go/abstore.go` 为例，链码实现了 `Init()`, `Invoke()`, `Query()`, `Delete()` 接口。

``` go
package main

import (
        "errors"
        "fmt"
        "strconv"

        "github.com/hyperledger/fabric-contract-api-go/contractapi"
)

// ABstore Chaincode implementation
type ABstore struct {
        contractapi.Contract
}

func (t *ABstore) Init(ctx contractapi.TransactionContextInterface, A string, Aval int, B string, Bval int) error {
        fmt.Println("ABstore Init")
        var err error
        // Initialize the chaincode
        fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)
        // 将账户 A 的状态写入账本（数据库）
        err = ctx.GetStub().PutState(A, []byte(strconv.Itoa(Aval)))
        if err != nil {
                return err
        }
		// 将账户 B 的状态写入账本（数据库）
        err = ctx.GetStub().PutState(B, []byte(strconv.Itoa(Bval)))
        if err != nil {
                return err
        }

        return nil
}

// 交易，A 转账给 B
func (t *ABstore) Invoke(ctx contractapi.TransactionContextInterface, A, B string, X int) error {
        var err error
        var Aval int
        var Bval int
        // Get the state from the ledger
        // TODO: will be nice to have a GetAllState call to ledger
        Avalbytes, err := ctx.GetStub().GetState(A)
        if err != nil {
                return fmt.Errorf("Failed to get state")
        }
        if Avalbytes == nil {
                return fmt.Errorf("Entity not found")
        }
        Aval, _ = strconv.Atoi(string(Avalbytes))

        Bvalbytes, err := ctx.GetStub().GetState(B)
        if err != nil {
                return fmt.Errorf("Failed to get state")
        }
        if Bvalbytes == nil {
                return fmt.Errorf("Entity not found")
        }
        Bval, _ = strconv.Atoi(string(Bvalbytes))

        // 执行交易操作
        Aval = Aval - X
        Bval = Bval + X
        fmt.Printf("Aval = %d, Bval = %d\n", Aval, Bval)

        // 将新的状态写入账本
        err = ctx.GetStub().PutState(A, []byte(strconv.Itoa(Aval)))
        if err != nil {
                return err
        }

        err = ctx.GetStub().PutState(B, []byte(strconv.Itoa(Bval)))
        if err != nil {
                return err
        }

        return nil
}

// 删除操作
func (t *ABstore) Delete(ctx contractapi.TransactionContextInterface, A string) error {

        // Delete the key from the state in ledger
        err := ctx.GetStub().DelState(A)
        if err != nil {
                return fmt.Errorf("Failed to delete state")
        }

        return nil
}

// 查询操作
func (t *ABstore) Query(ctx contractapi.TransactionContextInterface, A string) (string, error) {
        var err error
        // Get the state from the ledger
        Avalbytes, err := ctx.GetStub().GetState(A)
        if err != nil {
                jsonResp := "{\"Error\":\"Failed to get state for " + A + "\"}"
                return "", errors.New(jsonResp)
        }

        if Avalbytes == nil {
                jsonResp := "{\"Error\":\"Nil amount for " + A + "\"}"
                return "", errors.New(jsonResp)
        }

        jsonResp := "{\"Name\":\"" + A + "\",\"Amount\":\"" + string(Avalbytes) + "\"}"
        fmt.Printf("Query Response:%s\n", jsonResp)
        return string(Avalbytes), nil
}
// 程序入口
func main() {
        cc, err := contractapi.NewChaincode(new(ABstore))
        if err != nil {
                panic(err.Error())
        }
        if err := cc.Start(); err != nil {
                fmt.Printf("Error starting ABstore chaincode: %s", err)
        }
}
```

